# Instrumented deterministic test for queue feature
package require sqlite3

proc run_case {label queueEnabled expectBusy} {
  set envval [expr {$queueEnabled ? 1 : 0}]
  set ::env(SQLITE_QUEUE_ENABLED) $envval
  set ::env(SQLITE_QUEUE_TEST_MODE) 1
  file delete -force test_queue_instr.db
  sqlite3 db test_queue_instr.db
  db eval {CREATE TABLE t(id INTEGER PRIMARY KEY, v TEXT);}
  set rc1 [catch {db eval {BEGIN IMMEDIATE}} msg1]
  if {$rc1} {puts "$label: begin failed $msg1"; exit 1}
  # First write (should always succeed)
  set rc2 [catch {db eval {INSERT INTO t(v) VALUES('a');}} msg2]
  if {$rc2} {puts "$label: first write failed $msg2"; exit 1}
  # Second write triggers instrumentation path
  set rc3 [catch {db eval {INSERT INTO t(v) VALUES('b');}} msg3]
  if {$expectBusy} {
    if {!$rc3 || ![string match *BUSY* $msg3]} {
      puts "$label: EXPECTED BUSY, got rc=$rc3 msg=$msg3"; exit 1
    } else {puts "$label: got expected BUSY"}
    db eval {ROLLBACK}
  } else {
    if {$rc3} {puts "$label: unexpected failure rc=$rc3 msg=$msg3"; exit 1}
    db eval {COMMIT}
    set count [db eval {SELECT count(*) FROM t}]
    if {$count != 2} {puts "$label: expected 2 rows, got $count"; exit 1}
    puts "$label: success with 2 rows"
  }
  db close
}

run_case enabled 1 0
run_case disabled 0 1
puts "Instrumentation test PASSED"
exit 0
